import { _t } from "@web/core/l10n/translation";
import { getTemplate } from "@web/core/templates";
import { useService } from "@web/core/utils/hooks";
import { App, onWillUnmount, reactive, useExternalListener, useState } from "@odoo/owl";

import { BoxLayer } from '@iap_extract/components/manual_correction/box_layer';


/**
 * This is the renderer mixin of the subview that adds OCR features on the attachment
 * preview. It displays boxes that have been generated by the OCR. The OCR
 * automatically selects a box, but the user can manually selects another box.
 * T should be a subclass of FormRenderer (e.g. invoice_extract_form.js or bank_statement_extract_form.js)
 */
export const ExtractMixinFormRenderer = (T) => class extends T {
    /**
     * @override
     */
    setup() {
        super.setup();

        /** @type {import("@mail/core/common/store_service").Store} */
        this.store = useService("mail.store");
        this.dialog = useService("dialog");
        this.orm = useService("orm");
        this.mailPopoutService = useService("mail.popout");

        this._fieldsMapping = {}; // to override in the subclass
        this.recordModel = null; // to override in the subclass

        // This contain the record id of the fetched data.
        // It needs to be tracked as, if another record is loaded, we should fetch the data of the new record.
        this.recordId = -1;

        this.boxLayerApps = [];
        this.activeField = undefined;
        this.activeFieldEl = undefined;
        this.boxes = [];
        this.selectedBoxes = {};

        this.state = useState({
            visibleBoxes: {},
        });

        useExternalListener(window, "focusin", (event) => {
            const field_widget = event.target.closest(".o_field_widget");
            if (field_widget){
                this.onFocusFieldWidget(field_widget);
            }
        });

        useExternalListener(window, "focusout", (event) => {
            if (event.target.closest(".o_field_widget") && !this.mailPopoutService.externalWindow){
                this.onBlurFieldWidget();
            }
        });

        onWillUnmount (() => {
            this.destroyBoxLayers();
        });
    }

    fetchBoxData() {
        this.recordId = this.props.record.resId;
        return this.orm.call(this.recordModel, 'get_boxes', [this.props.record.resId]);
    }

    /**
     * Launch an Owl App with the box layer as root component.
     */
    createBoxLayerApp(props) {
        props.onClickBoxCallback = this.onClickBox.bind(this);
        return new App(BoxLayer, {
            env: this.env,
            dev: this.env.debug,
            getTemplate,
            props,
            translatableAttributes: ["data-tooltip"],
            translateFn: _t,
        });
    }

    /**
     * Renders the box layers on @element.
     * If a box layer already exists, it is re-used.
     */
    renderBoxLayers(element) {
        const proms = [];
        // In case of img
        if (element.classList.contains('img-fluid')) {
            this.destroyBoxLayers();
            const boxLayerApp = this.createBoxLayerApp({
                boxes: this.state.visibleBoxes[0] || [],
                mode: 'img',
                pageLayer: element,
            });
            proms.push(boxLayerApp.mount(element.parentElement));
            this.boxLayerApps = [boxLayerApp];
        }
        // In case of pdf
        if (element.tagName === 'IFRAME') {
            // Dynamically add css on the pdf viewer
            const pdfDocument = element.contentDocument;
            if (!pdfDocument.querySelector('head link#box_layer')) {
                const win = this.mailPopoutService.externalWindow || window;
                const boxLayerStylesheet = win.document.createElement('link');
                boxLayerStylesheet.setAttribute('id', 'box_layer');
                boxLayerStylesheet.setAttribute('rel', 'stylesheet');
                boxLayerStylesheet.setAttribute('type', 'text/css');
                boxLayerStylesheet.setAttribute('href', '/iap_extract/static/src/components/manual_correction/box_layer.css');
                pdfDocument.querySelector('head').append(boxLayerStylesheet);
            }
            const pageLayers = pdfDocument.querySelectorAll('.page');
            for (const pageLayer of pageLayers) {
                const pageNum = pageLayer.dataset['pageNumber'] - 1;
                const boxLayerApp = this.createBoxLayerApp({
                    boxes: this.state.visibleBoxes[pageNum] || [],
                    mode: 'pdf',
                    pageLayer: pageLayer,
                });
                proms.push(boxLayerApp.mount(pageLayer));
                this.boxLayerApps.push(boxLayerApp);
            }
        }
        return Promise.all(proms);
    }

    shouldRenderBoxes() {
        const thread = this.store.Thread.insert({
            id: this.props.record.resId,
            model: this.props.record.resModel,
        });
        return (
            ['waiting_validation', 'validation_to_send'].includes(this.props.record.data.extract_state) &&
            this.props.record.data.extract_attachment_id &&
            thread.mainAttachment.id === this.props.record.data.extract_attachment_id[0]
        )
    }

    /**
     * Renders the boxes on @attachment.
     * It also determines which boxes should be visible according to the current active field.
     */
    renderExtract(attachment) {
        if (this.shouldRenderBoxes()) {
            if (this.activeField !== undefined) {
                if (this.recordId !== this.props.record.resId) {
                    for (const boxesForPage of Object.values(this.boxes)) {
                        boxesForPage.length = 0;
                    }
                }
                const dataToFetch = this.boxes.length === 0 || (this.recordId !== this.props.record.resId);
                const prom = dataToFetch ? this.fetchBoxData() : new Promise(resolve => resolve([]));
                prom.then((boxes) => {
                    boxes.map(b => reactive(b)).forEach((box) => {
                        if (box.page in this.boxes) {
                            this.boxes[box.page].push(box);
                        }
                        else {
                            this.boxes[box.page] = [box];
                        }
                        if (box.user_selected) {
                            this.selectedBoxes[box.feature] = box;
                        }
                    });
                    for (const [page, boxesForPage] of Object.entries(this.boxes)) {
                        if (page in this.state.visibleBoxes) {
                            this.state.visibleBoxes[page].length = 0;
                        }
                        else {
                            this.state.visibleBoxes[page] = [];
                        }

                        const visibleBoxesForPage = boxesForPage.filter((box) => {
                            return (
                                box.feature === this.activeField ||
                                (box.feature === "VAT_Number" && this.activeField === "supplier")
                            );
                        });
                        this.state.visibleBoxes[page].push(...visibleBoxesForPage);
                    }
                    this.renderBoxLayers(attachment)
                });
            }
        }
    }

    /**
     * Determines the DOM element on which the boxes must be rendered, then render them.
     */
    showBoxesForField(fieldName) {
        // Case pdf (iframe)
        const win = this.mailPopoutService.externalWindow || window;
        const iframe = win.document.querySelector('.o-mail-Attachment iframe');
        if (iframe) {
            const iframeDoc = iframe.contentDocument;
            if (iframeDoc) {
                this.renderExtract(iframe);
                return;
            }
        }
        // Case img
        const attachment = win.document.getElementById('attachment_img');
        if (attachment && attachment.complete) {
            this.renderExtract(attachment);
            return;
        }
    }

    resetActiveField() {
        Object.values(this.state.visibleBoxes).forEach(boxesForPage => {
            boxesForPage.length = 0;
        });
        this.activeField = undefined;
        this.activeFieldEl = undefined;
        this.destroyBoxLayers();
    }

    destroyBoxLayers() {
        for (const boxLayerApp of this.boxLayerApps) {
            boxLayerApp.destroy();
        }
        this.boxLayerApps = [];
    }

    /**
     * Updates the field's value according to @newFieldValue.
     */
    async handleFieldChanged(fieldName, newFieldValue) {
        // to override in the subclass
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Called when a field widget gains focus.
     * It serves as the entry point to render the boxes of the focused field.
     */
    onFocusFieldWidget(field_widget) {
        const fieldName = this._fieldsMapping[field_widget.getAttribute('name')];

        if (fieldName === undefined) {
            this.resetActiveField();
            return;
        }

        this.activeField = fieldName;
        this.activeFieldEl = field_widget;

        this.showBoxesForField(fieldName);
    }

    /**
     * Called when a field widget loses focus.
     * It hides all boxes.
     */
    onBlurFieldWidget() {
        this.resetActiveField();
    }

    async onClickBox(boxId, boxPage) {
        const box = this.boxes[boxPage].find(box => box.id === boxId);
        const fieldName = box.feature;

        // Unselect the previously selected box
        if (this.selectedBoxes[fieldName]) {
            this.selectedBoxes[fieldName].user_selected = false;
        }

        // Select the new box
        box.user_selected = true;
        this.selectedBoxes[fieldName] = box;

        // Update the selected box in database
        const newFieldValue = await this.orm.call(
            this.recordModel,
            'set_user_selected_box',
            [[this.dataMoveId], boxId],
        )

        // Update the field's value
        await this.handleFieldChanged(fieldName, newFieldValue);

        if (['supplier', 'VAT_Number'].includes(box.feature)) {
            this.activeFieldEl.querySelector('.o-autocomplete--dropdown-menu')?.classList.toggle('show');
        } else if (['date', 'due_date'].includes(box.feature)) {
            // For the date fields, we want to hide the calendar tooltip
            // This is achieved by simulating an 'ESC' keypress
            this.activeFieldEl.querySelector('input').dispatchEvent(new KeyboardEvent('keydown', {
                key: 'Escape',
            }));
        }
    }
};
